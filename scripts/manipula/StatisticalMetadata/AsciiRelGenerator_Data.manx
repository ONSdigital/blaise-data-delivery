
{*************************************************}
{                                                 }
{  Blaise 5. A Survey Processing System           }
{  Copyright (c) 2024 Statistics Netherlands      }
{                                                 }
{*************************************************}
SETUP AsciiRelGenerator_Data

//
//Version: 1.01 
//Date October 7, 2020
//
//This setup can be used to generate ASCII relational output files
//Per block type all instances of that type are be written to a separate file.
//
//The setup requires a data file that contains information about the
//blocks in the datamodel. This file is produced by running the 
//AsciiRelGenerator_Meta script.
//The name of the file required for meta x.bmix is x.names.xml.
//When offroute/unprocessed is required in the output:   
//The setup requires a data file that contains some information about the
//fields per block in the datamodel. This file is produced by running the 
//AsciiRelGenerator_Meta script.
//The name of the file required for meta x.bmix is x.blockmeta.xml.   
//
//Command-line parameters for this script:
//- the bmix (prepared meta) of the data to process. -K:Meta=<filename>
//- the name of the data file to process. -N:iData=<filename>
//- the base name of the output file. -N:oData=<filename>
//- The following -P: command are available:
//  parameter(1): OffRoute & Unprocessed in output. Default=no.
//                To activate specify the value Y 
//  parameter(2): Separator. Default: no separator
//                To activate specify the character to be used or TAB
//  parameter(3): Export to ANSI. To activate spcify the value Y
// 
//The data is exported to ASCII files with the following name convention:
//  Data of an instance of block <z> is written to file y.bdix.<z>.asc
//  Data of the main block is written to y.bdix.$main.asc
//  Data of OPEN fields is written to y.bdix.$open.asc
//  Data of BLOBTYPE fields is written to y.bdix.$blob.asc
//  Values of field properties are written to y.bdix.$fps.asc
//
{.$DEFINE DEBUG}       
{.$DEFINE TESTIMPORT}  //generate the instructions to import the generated .asc block files in Blaise databases 
{$DEFINE UseBlockMetaXML} //use XML file that contains the meta data including offroute/unprocessed attributes
                          //when disable the block based .bmix file will be used. This requires a call to
                          //loadDataModel when a different blocktype needs to be processed. Seems somewhat slower 
                          //than using the Block Meta xml file. 
SETTINGS
  AUTOREAD=NO 
  {$IFDEF DEBUG}
  DAYFILE = 'asciirelgenerator_data_day.txt'
  MESSAGEFILE = 'asciirelgenerator_data_message.txt'
  {$ENDIF}

USES
  Meta (VAR)
  
  BlockMeta (VAR) 
  
  DATAMODEL BlockInfo
  PRIMARY BlockFieldName
  SECONDARY
    BlockTypeName, Number
  FIELDS
    BlockTypeName: STRING[150]
    Number: INTEGER[5]
    BlockFieldName: STRING[180]
    BlockTypeText: STRING
    ArrayMin: INTEGER[3]
    ArrayMax: INTEGER[3]
    Instance: INTEGER[5]
    OwnerTypeName: STRING[150] //for $open & $fps &blob
    LocalName: STRING[80]  //for $open & $fps & $blob
    Level: INTEGER[2]
    VarCount: INTEGER[5]
    VarLength: INTEGER[7]
  ENDMODEL

  DATAMODEL BlockType
  PRIMARY Name
  FIELDS
    Name: STRING[150]
  ENDMODEL   
  DATAMODEL DataOut
  FIELDS
    Value: STRING[40000]
  ENDMODEL   
  DATAMODEL Text
  FIELDS
    line: STRING[2000]
  ENDMODEL  
 
  DATAMODEL BlockTypeMeta
  PRIMARY
    BlockTypeName, FieldName, Property
  FIELDS
    BlockTypeName: STRING
    FIndex: INTEGER
    FPosition: INTEGER
    FText: STRING
    FieldName: STRING
    FType: STRING
    FMax: INTEGER
    FMin: INTEGER
    FDecimals: INTEGER
    FSetSize: INTEGER
    FArrayLen: INTEGER
    Property: STRING[20] //value of property 
    Value: STRING
  ENDMODEL   
  
  
INPUTFILE iData:Meta (BDIX) 
SETTINGS
  CONNECT=NO
  OPEN=NO
 
INPUTFILE MyBlocksGenI: BlockInfo (XML) //generated by the AsciiRelGenerator_Meta.manx setup
SETTINGS
  OPEN=NO
  
INPUTFILE MyBlocksMetaGenI: BlockTypeMeta (XML) //generated by the AsciiRelGenerator_Meta.manx setup
SETTINGS
  OPEN=NO

TEMPORARYFILE MyBlocks: BlockInfo  

TEMPORARYFILE MyBlockTypeMeta: BlockTypeMeta  

OUTPUTFILE oData: DataOut (ASCII)
SETTINGS
  TRAILINGSPACES=NO
  OPEN=NO
  CREATEBDIX=NO
  REMOVEEMPTY=YES
  
OUTPUTFILE oData_Block: DataOut (ASCII)
SETTINGS
  TRAILINGSPACES=NO
  OPEN=NO
  CREATEBDIX=NO
  
{$IFDEF TESTIMPORT}
OUTPUTFILE TestRun:text ('testrun.txt',ASCII)
SETTINGS
  TRAILINGSPACES=NO
  CREATEBDIX = NO
{$ENDIF}  
  
AUXFIELDS (GLOBAL)
  auxCurrentBlockTypeName: STRING  
  MaxBlockTypeLen: INTEGER
  MaxBlockNameLen: INTEGER
  MaxLocalNameLen: INTEGER
  MaxFieldPropertyLen: INTEGER
  MaxFieldPropertyValueLen: INTEGER
  MaxOwnerTypeName: INTEGER
  FixedField: (Yes,No)
  MaxModeLen: INTEGER
  BlaiseDataFileName: STRING
  BaseDataName: STRING
  BaseDataExt: STRING
  DoWriteANSI: (Yes), EMPTY
  
AUXFIELDS 
  SepChar: STRING[1]
  DelimChar: STRING[1]
  AlsoExportOpen: INTEGER    
  AlsoExportBlob: INTEGER
  RepeatSpecialAnswerInSet: (Yes, No(0)) //default=repeat the special answer
  UserDefSpecialAnswers: (Yes,No)
  RunRules: (Yes (1),No (0))
  CurrentBN: string 
  
include "fileutils.incx"

//meta routines
FUNCTION GetTextSize: STRING
PARAMETERS
  pFieldname: string
AUXFIELDS
  lname: STRING
INSTRUCTIONS
  IF RunRules=1 THEN
    lname:= [[iData.GetField(pFieldName).LocalName]]
{$IFDEF UseBlockMetaXML}    
    MyBlockTypeMeta.GET(auxCurrentBlockTypeName,lname,':size')
    RESULT:= MyBlockTypeMeta.Value
{$ELSE}    
    Result:= [[BlockMeta.GetField(lname).TextSize('')]]
{$ENDIF}    
  ELSE
    RESULT:= [[Meta.GetField(pFieldName).TextSize('')]]
  ENDIF  
ENDFUNCTION  
  
FUNCTION StripText: OPEN
PARAMETERS ptext: OPEN
AUXFIELDS  
  tmp, tmp1,tmp2: OPEN
  p1,p2: INTEGER
INSTRUCTIONS
  tmp:= ptext
  tmp:= REPLACE(tmp,'\<','#1')
  tmp:= REPLACE(tmp,'\>','#2')
  tmp:= REPLACE(tmp,'<newline>','@/',TRUE)
  p1:= POSITION('<',tmp)
  p2:= POSITION('>',tmp)
  WHILE (p1>0) AND (p2>0) AND (p2>p1)  DO
     tmp1:=  SUBSTRING(tmp,1,p1-1)
     tmp2:=  SUBSTRING(tmp,p2+1,LEN(tmp))
     tmp:= tmp1+tmp2
     p1:= POSITION('<',tmp)
     p2:= POSITION('>',tmp)
  ENDWHILE
  tmp:= REPLACE(tmp,'#1','\<')
  tmp:= REPLACE(tmp,'#2','\>')
  REPEAT
    tmp:= REPLACE(tmp,'  ',' ')
  UNTIL POSITION('  ',tmp)=0  
  RESULT:= tmp
ENDFUNCTION

FUNCTION IsOfTypeOpen: INTEGER
PARAMETERS pFieldName: STRING
INSTRUCTIONS
  IF [[iData.GetField(pFieldName).Definition.Type.Structure]]='String' AND  [[iData.GetField(pFieldName).Definition.Type.MaxLength]]='' THEN
    RESULT:= 1
  ELSE
    RESULT:= 0
  ENDIF        
ENDFUNCTION

FUNCTION IsOfTypeBlob: INTEGER
PARAMETERS pFieldName: STRING
INSTRUCTIONS
  IF [[iData.GetField(pFieldName).Definition.Type.Structure]]='Blob' THEN
    RESULT:= 1
  ELSE
    RESULT:= 0
  ENDIF        
ENDFUNCTION

FUNCTION WriteOpen: STRING
PARAMETERS 
  pFieldName: STRING
  pSpecialAnswer: INTEGER
  pKey: STRING
  pINumber: INTEGER
AUXFIELDS
  tmp: OPEN
  aHeader: OPEN  
  LFN, BFN: STRING
INSTRUCTIONS
//Struture of record is as follows:
// '$open' : STRING[MaxBlockTypeLen]  //removed before the actual write to file
// _BlockName: STRING[MaxBlockNameLen] 
// _PrimaryKey: STRING[primkeylen]   or _FormNumber: INTEGER[8]
// _InstanceNr: 1..99999
// _CollectionMode: string[maxmodelen]    //only present if applicable 
// _ParentBlockType: STRING[MaxBlockTypeLen]
// _ParentInstanceNr: 1..9999
// _LocalName: STRING[MaxLocalNameLen]
// OpenAnswer: STRING[20000] //actual value or special answer. Output will not have CR-LF. They will be replaced  
   MyBlocks.GET(pFieldName) 
   IF FixedField=No THEN  
     RESULT:= STR(MyBlocks.Instance) 
   ELSE
     RESULT:= STR(MyBlocks.Instance,5) 
   ENDIF  
   //Now make the record...
   IF POSITION('.',pFieldName)>0 THEN
     LFN:= SUBSTRING(Regexstring('\\.\\w+$',pFieldName),2,255)  //local name
     BFN:= SUBSTRING(pFieldName,1,LEN(pFieldName)-LEN(LFN)-1)
   ELSE
     LFN:= pFieldName
     BFN:= '$main'
   ENDIF  
   aHeader:= FORMAT('$open', MaxBlockTypeLen)+SepChar+
             FORMAT(BFN, MaxBlockNameLen)+SepChar+
             pKey+SepChar+STR(MyBlocks.Instance,5)+SepChar
   IF MaxModeLen<>0 THEN
     aHeader:= aHeader+FORMAT([[iData.ActiveMode]],MaxModeLen)+SepChar
   ENDIF
   oData.Value:= aHeader  
   IF FixedField=No THEN  
     oData.Value:= oData.Value+
        MyBlocks.OwnerTypeName+SepChar+
        STR(pINumber)+Sepchar+
        LFN+SepChar
   ELSE  
     oData.Value:= oData.Value+
        FORMAT(MyBlocks.OwnerTypeName,MaxBlockTypeLen)+
        STR(pINumber,5)+
        FORMAT(LFN,MaxLocalNameLen)
   ENDIF
   IF pSpecialAnswer=1 THEN
     tmp:= [[iData.GetField(pFieldName).DataValue.ValueAsText]]
   ELSE
     tmp:= [[iData.GetField(pFieldName).DataValue.StringValue]]
   ENDIF  
   IF FixedField=No THEN
     IF POSITION(SepChar,tmp)>0 THEN
       tmp:= DelimChar+REPLACE(tmp,DelimChar,DelimChar+DelimChar)+DelimChar 
     ENDIF
   ENDIF
   oData.Value:= oData.Value+tmp  
   oData.WRITE
ENDFUNCTION   

FUNCTION WriteBlob: STRING
PARAMETERS 
  pFieldName: STRING
  pSpecialAnswer: INTEGER
  pKey: STRING
  pINumber: INTEGER
AUXFIELDS
  tmp: STRING
  tmpFileName: STRING
  tmpB: BLOBTYPE
  aHeader: OPEN  
  LFN, BFN: STRING
INSTRUCTIONS
//Struture of record is as follows:
// '$open' : STRING[MaxBlockTypeLen]  //removed before the actual write to file
// _BlockName: STRING[MaxBlockNameLen] 
// _PrimaryKey: STRING[primkeylen]   or _FormNumber: INTEGER[8]
// _InstanceNr: 1..99999
// _CollectionMode: string[maxmodelen]    //only present if applicable 
// _ParentBlockType: STRING[MaxBlockTypeLen]
// _ParentInstanceNr: 1..9999
// _LocalName: STRING[MaxLocalNameLen]
// BlobFileName: STRING[100]
   MyBlocks.GET(pFieldName) 
   IF FixedField=No THEN  
     RESULT:= STR(MyBlocks.Instance) 
   ELSE
     RESULT:= STR(MyBlocks.Instance,5) 
   ENDIF  
   //Now make the record...
   IF POSITION('.',pFieldName)>0 THEN
     LFN:= SUBSTRING(Regexstring('\\.\\w+$',pFieldName),2,255)  //local name
     BFN:= SUBSTRING(pFieldName,1,LEN(pFieldName)-LEN(LFN)-1)
   ELSE
     LFN:= pFieldName
     BFN:= '$main'
   ENDIF  
   aHeader:= FORMAT('$blob', MaxBlockTypeLen)+SepChar+
             FORMAT(BFN, MaxBlockNameLen)+SepChar+
             pKey+SepChar+STR(MyBlocks.Instance,5)+SepChar
   IF MaxModeLen<>0 THEN
     aHeader:= aHeader+FORMAT([[iData.ActiveMode]],MaxModeLen)+SepChar
   ENDIF
   oData.Value:= aHeader  
   IF FixedField=No THEN  
     oData.Value:= oData.Value+
        MyBlocks.OwnerTypeName+SepChar+
        STR(pINumber)+Sepchar+
        LFN+SepChar
   ELSE  
     oData.Value:= oData.Value+
        FORMAT(MyBlocks.OwnerTypeName,MaxBlockTypeLen)+
        STR(pINumber,5)+
        FORMAT(LFN,MaxLocalNameLen)
   ENDIF
   IF pSpecialAnswer=1 THEN
     tmp:= [[iData.GetField(pFieldName).DataValue.ValueAsText]]
   ELSE
     tmp:= [[iData.GetField(pFieldName).DataValue.BlobValue.FileName]]
     //future extension: also export actual blob to a file on disk...
   ENDIF  
   IF FixedField=No THEN
     IF POSITION(SepChar,tmp)>0 THEN
       tmp:= DelimChar+REPLACE(tmp,DelimChar,DelimChar+DelimChar)+DelimChar 
     ENDIF
   ENDIF
   oData.Value:= oData.Value+tmp  
   oData.WRITE
ENDFUNCTION   

FUNCTION ResponseAnswerOfEndField: OPEN
PARAMETERS 
  pFieldName: STRING
  pKey: STRING
  pINumber: INTEGER
AUXFIELDS
  MyType: STRING
  tmp: OPEN
  SetValue: STRING
  SetL, CC, J, P: INTEGER
  Size: INTEGER
  SetStr: STRING
  aKey: STRING
  aMode: STRING
INSTRUCTIONS
  RESULT:= ''
  MyType:= [[iData.GetField(pFieldName).Definition.Type.Structure]]
  IF FixedField=Yes THEN 
    Size:= VAL(GetTextSize(pFieldName))
  ENDIF
  CASE MyType of
  'Enumeration': 
     RESULT:= [[iData.GetField(pFieldName).DataValue.EnumerationValue]] 
     IF FixedField=Yes THEN RESULT:= FORMAT(RESULT,Size,RIGHT) ENDIF
  'Integer': 
     RESULT:= [[iData.GetField(pFieldName).DataValue.IntegerValue]]
     IF FixedField=Yes THEN RESULT:= FORMAT(RESULT,Size,RIGHT) ENDIF
  'Real': 
     RESULT:= [[iData.GetField(pFieldName).DataValue.ValueAsText]] //not .RealValue because it has locale decimal symbol
     IF FixedField=Yes THEN RESULT:= FORMAT(RESULT,Size,RIGHT) ENDIF
  'String': 
     IF IsOfTypeOpen(pFieldName)=0 THEN
       RESULT:= [[iData.GetField(pFieldName).DataValue.StringValue]]
       IF FixedField=No AND POSITION(SepChar,RESULT)>0 THEN
         RESULT:= DelimChar+REPLACE(RESULT,DelimChar,DelimChar+DelimChar)+DelimChar 
       ENDIF
       IF FixedField=Yes THEN RESULT:= FORMAT(RESULT,Size,LEFT) ENDIF
     ELSE
       IF AlsoExportOpen=1 THEN
         RESULT:= WriteOpen(pFieldName,0,pKey,pINumber)
       ENDIF  
     ENDIF
  'Blob': IF AlsoExportBlob=1 THEN
            RESULT:= WriteBlob(pFieldName,0,pKey,pINumber)
          ENDIF  
  'Time': RESULT:= [[iData.GetField(pFieldName).DataValue.ValueAsText]]
  'Date': RESULT:= REPLACE([[iData.GetField(pFieldName).DataValue.ValueAsText]],'-','') //fixed format ddMMyyyy
  'Classification': 
     RESULT:= [[iData.GetField(pFieldName).DataValue.ValueAsText]]
     IF FixedField=Yes THEN RESULT:= FORMAT(RESULT,Size,RIGHT) ENDIF
  'Set': 
    IF [[iData.GetField(pFieldName).Definition.Type.Cardinality]]<>'' THEN
      SetL:= VAL([[iData.GetField(pFieldName).Definition.Type.Cardinality]])
    ELSE 
      SetL:= VAL([[iData.GetField(pFieldName).Definition.Type.MemberType.Categories.Count]])
    ENDIF
    SetValue:= [[iData.GetField(pFieldName).DataValue.ValueAsText]]
    cc:= 0
    FOR j:= 1 TO LEN(setvalue) DO 
      IF SUBSTRING(SetValue,j,1)='-' THEN 
        cc:= cc+1 
      ENDIF 
    ENDDO
    IF FixedField=No THEN
      SetValue:= REPLACE(SetValue,'-',SepChar) 
      RESULT:= SetValue+FILL(SepChar,SetL-cc-1)
    ELSE
      SetStr:= ''
      IF SetL=1 or CC=0 THEN 
        SetStr:= FORMAT(setvalue,Size,RIGHT)
      ELSE
        P:= POSITION('-',SetValue)
        REPEAT
          SetStr:= SetStr+FORMAT(SUBSTRING(SetValue,1,P-1),Size,RIGHT)
          SetValue:= SUBSTRING(SetValue,P+1,255)
          P:= POSITION('-',SetValue)
        UNTIL p=0     
        SetStr:= SetStr+FORMAT(setvalue,Size,RIGHT)
      ENDIF   
      RESULT:= SetStr+FILL(' ',(SetL-cc-1)*Size)
    ENDIF    
  ENDCASE
ENDFUNCTION

FUNCTION GetSpecialAnswerValue: STRING
PARAMETERS
  pFieldName: STRING
  pSpecialA: STRING
AUXFIELDS
  lname: STRING
INSTRUCTIONS
  IF RunRules=1 THEN
    lname:= [[iData.GetField(pFieldName).LocalName]]
{$IFDEF UseBlockMetaXML}    
    MyBlockTypeMeta.GET(auxCurrentBlockTypeName,lname,pSpecialA)
    RESULT:= MyBlockTypeMeta.Value
{$ELSE}
    RESULT:= [[BlockMeta.GetField(lname).AllSpecialAnswers.GetSpecialAnswerTextFileValue(pSpecialA)]]
{$ENDIF}    
  ELSE
    RESULT:= [[Meta.GetField(pFieldName).AllSpecialAnswers.GetSpecialAnswerTextFileValue(pSpecialA)]]
  ENDIF
ENDFUNCTION


FUNCTION SpecialAnswerOfEndField: STRING
PARAMETERS 
  pFieldName: STRING
  pKey: STRING
  pINumber: INTEGER
AUXFIELDS
  MyType: STRING
  Tmp: STRING
  SetValue: STRING
  SetL, CC, J: INTEGER
  SpecialA: STRING
  SA: STRING
  aKey: STRING
  AmODE: STRING
INSTRUCTIONS
  MyType:= [[iData.GetField(pFieldName).Definition.Type.Structure]]
  IF MyType='Set' THEN
    IF [[iData.GetField(pFieldName).Definition.Type.Cardinality]]<>'' THEN
      SetL:= VAL([[iData.GetField(pFieldName).Definition.Type.Cardinality]])
    ELSE 
      SetL:= VAL([[iData.GetField(pFieldName).Definition.Type.MemberType.Categories.Count]])
    ENDIF
  ENDIF  
  SpecialA:= [[iData.GetField(pFieldName).DataValue.SpecialAnswer]]
  //from version 5.2.5 on it is easy to get hold of the value in ASCII for a Special Answer
  SA:= GetSpecialAnswerValue(pFieldName,SpecialA)
  IF MyType='Set' THEN
    If FixedField=No then
      IF RepeatSpecialAnswerInSet=1 THEN
        RESULT:= FILL(SA+SepChar,SetL-1)+SA //add as many separator as needed
      ELSE
        RESULT:= SA+FILL(SepChar,SetL-1) //add as many separator as needed
      ENDIF  
    ELSE
      IF RepeatSpecialAnswerInSet=1 THEN
        RESULT:= FILL(SA,SetL) //only first element received the SA, rest of set filled with spaces
      ELSE
        RESULT:= SA+FILL(' ',(SetL-1)*LEN(SA)) //only first element received the SA, rest of set filled with spaces
      ENDIF  
    ENDIF  
  ELSEIF IsOfTypeOpen(pFieldName)=1 THEN //OPEN type
    IF AlsoExportOpen=1 THEN
      RESULT:= WriteOpen(pFieldName,1,pKey,pINumber)
    ENDIF  
  ELSEIF IsOfTypeBlob(pFieldName)=1 THEN //OPEN type
    IF AlsoExportBlob=1 THEN
      RESULT:= WriteBlob(pFieldName,1,pKey,pINumber)
    ENDIF  
  ELSE
    Result:= SA
  ENDIF
ENDFUNCTION  

FUNCTION EmptyAnswerOfEndField: OPEN
PARAMETERS 
  pFieldName: STRING
AUXFIELDS
  MyType: STRING
  Tmp: STRING
  SetValue: STRING
  SetL, CC, J: INTEGER
  Size: INTEGER
  RouteStatus: STRING
  SpecialStatus: STRING
  EmptyVal: OPEN
INSTRUCTIONS
  MyType:= [[iData.GetField(pFieldName).Definition.Type.Structure]]
  IF FixedField=Yes THEN 
    IF IsOfTypeOpen(pFieldName)=1 THEN 
      Size:= 5 
    ELSE
      Size:= VAL(GetTextSize(pFieldName))
    ENDIF
  ENDIF
  If FixedField=No then
    EmptyVal:= ''
  ELSE
    EmptyVal:= FILL(' ',Size) 
  ENDIF  
  IF RunRules=Yes THEN
    RouteStatus:= [[iData.GetField(pFieldName).RouteStatus]]
    IF RouteStatus='OffRoute' THEN
      SpecialStatus:= 'OffRoute'
    ELSE
      IF [[iData.GetField(pFieldName).IsRequired]]='True' THEN
        SpecialStatus:= 'Unprocessed'  
      ENDIF
    ENDIF  
    EmptyVal:= GetSpecialAnswerValue(pFieldName,SpecialStatus)
  ENDIF
  IF MyType='Set' THEN
    IF [[iData.GetField(pFieldName).Definition.Type.Cardinality]]<>'' THEN
      SetL:= VAL([[iData.GetField(pFieldName).Definition.Type.Cardinality]])
    ELSE 
      SetL:= VAL([[iData.GetField(pFieldName).Definition.Type.MemberType.Categories.Count]])
    ENDIF
    If FixedField=No then
      RESULT:= FILL(EmptyVal+SepChar,SetL-1)+EmptyVal //add as many separator as needed
    ELSE
      RESULT:= FILL(EmptyVal,SetL) //only first element received the SA, rest of set filled with spaces
    ENDIF  
  ELSE
    Result:= EmptyVal
  ENDIF   
ENDFUNCTION  

FUNCTION ValueOfEndField: OPEN 
PARAMETERS 
  pBlockName: STRING
  pFieldName: STRING
  pKey: STRING
  pINumber: INTEGER
INSTRUCTIONS
  IF RunRules=1 THEN
    IF pBlockName='' THEN
      LoadBlockMeta('')
    ELSE
      LoadBlockMeta([[iData.GetField(pBlockName).Definition.Type.HierarchicalName]])
    ENDIF  
  ENDIF
  IF [[iData.GetField(pFieldName).DataValue.AnswerStatus]]='Response' THEN 
    Result:= ResponseAnswerOfEndField(pFieldName,pKey,pINumber)             
  ELSEIF [[iData.GetField(pFieldName).DataValue.AnswerStatus]]='SpecialAnswer' THEN
    Result:= SpecialAnswerOfEndField(pFieldName,pKey,pINumber)
  ELSE
    Result:= EmptyAnswerOfEndField(pFieldName)
  ENDIF  
ENDFUNCTION  

FUNCTION FieldPropertyValueOfEndField: OPEN 
PARAMETERS 
  pFieldName: STRING
  pFieldProperty: STRING
INSTRUCTIONS
  RESULT:= [[iData.GetField(pFieldName).FieldProperties.GetItem(pFieldProperty).Value.ValueAsText]]
ENDFUNCTION  

PROCEDURE ProcessFieldProperties
PARAMETERS 
  pKey: STRING
  pBlockName: STRING
  pINumber: INTEGER
  pFieldName: STRING
  pBlockType: STRING
AUXFIELDS 
  AS: STRING  
  FPV: OPEN
  i: INTEGER
  FPN: STRING
  BFN, LFN: STRING
  aHeader: OPEN
  aBlockName: STRING
INSTRUCTIONS
//Struture of record is as follows:
// '$fps' : STRING[MaxBlockTypeLen]  //removed before the actual write to file
// _BlockName: STRING[MaxBlockNameLen]
// _PrimaryKey: STRING[primkeylen]   or _FormNumber: INTEGER[8]
// _InstanceNr: 1..99999
// _CollectionMode: string[maxmodelen]    //if applicable 
// _BlockTypeName: STRING[MaxBlockNameLen]
// _LocalName: STRING[MaxLocalNameLen]
// _FieldProperty: STRING[MaxFieldPropertyLen]
// _Value: STRING[]   //length depends of field property type
  IF MaxFieldPropertyLen>0 THEN
    IF POSITION('.',pFieldName)>0 THEN
      LFN:= SUBSTRING(Regexstring('\\.\\w+$',pFieldName),2,255)  //local name
      BFN:= SUBSTRING(pFieldName,1,LEN(pFieldName)-LEN(LFN)-1)
    ELSE
      LFN:= pFieldName
      BFN:= '$main'
    ENDIF  
    aHeader:= FORMAT('$fps',MaxBlockTypeLen)+SepChar+
              FORMAT(BFN, MaxBlockNameLen)+SepChar+ //fully qualified block name of the field
              pKey+SepChar+
              STR(pINumber,5)+SepChar
    IF MaxModeLen<>0 THEN
      aHeader:= aHeader+FORMAT([[iData.ActiveMode]],MaxModeLen)+SepChar
    ENDIF
    AS:= [[iData.GetField(pFieldName).DataValue.AnswerStatus]]
    
    IF AS='Response' OR AS='SpecialAnswer' OR [[iData.GetField(pFieldName).Definition.IsRequired]] = 'False' THEN //there can be a field property with a value
      FOR i:= 0 TO VAL([[iData.Datamodel.FieldProperties.Count]])-1 DO
        IF [[iData.Datamodel.FieldProperties[i].DataKind]]='Persistent' THEN
          FPN:= [[iData.Datamodel.FieldProperties[i].Name]]
          FPV:= FieldPropertyValueOfEndField(pFieldName,FPN)
          IF FPV<>EMPTY THEN
            oData.value:= aHeader                                 
            IF FixedField=Yes THEN
              oData.Value:= oData.Value+
                            FORMAT(pBlockType,MaxBlockNameLen)+  //owner block type name
                            FORMAT(LFN,MaxLocalNameLen)+         //local field name in owner block
                            FORMAT(FPN,MaxFieldPropertyLen)      //name of field property
            ELSE
              oData.Value:= oData.Value+
                            pBlockType+SepChar+                  //owner block type name
                            LFN+SepChar+                         //local field name in owner block
                            FPN+SepChar                          //name of field property
            ENDIF
            oData.Value:= oData.Value+FPV //the value of the field property                
            oData.Write              
          ENDIF  
        ENDIF
      ENDDO
    ENDIF      
  ENDIF  
ENDPROCEDURE

PROCEDURE LoadBlockMeta
PARAMETERS
  pBlockName: STRING 
AUXFIELDS
  res: INTEGER
  fpath,fname: STRING
  mfile: STRING
INSTRUCTIONS
{$IFDEF UseBlockMetaXML}
  if pBlockName='' THEN 
    auxCurrentBlockTypeName:= '$main'
  else  
    auxCurrentBlockTypeName:= pblockName
  endif
{$ELSE}  
  fPath:= ExtractFilePath([[meta.FileName]])
  IF pBlockName<>'' THEN
    fname:= fPath+[[meta.Name]]+'.'+pBlockName+'.bmix'
  ELSE
    fname:= fPath+[[meta.Name]]+'.$main.bmix'
  ENDIF
  IF fname<>CurrentBN THEN
    res:= blockmeta.loaddatamodel(fname)
    CurrentBN:= fname
  ENDIF
{$ENDIF}  
ENDPROCEDURE

PROCEDURE LoopBlocks 
PARAMETERS
  IMPORT pKey: STRING
  IMPORT pBlockName: STRING
  IMPORT pINumber: INTEGER
  IMPORT pBlockTypeName: STRING
  IMPORT pOINumber: INTEGER
  IMPORT pOBlockTypeName: STRING
  Import Nest:INTEGER
AUXFIELDS 
  min_a, max_a: INTEGER
  MyType, MyKind, MyTypeName, AName: STRING
  index, aindex, j: INTEGER
  FN: STRING
  FID: STRING
  s: STRING
  c: INTEGER
  MyValue: OPEN
  CC: INTEGER
  SetValue: STRING
  FVal: STRING
  SetL: INTEGER
  Ins: INTEGER
  BTName: STRING
  aLocName: STRING
  MyHeader: STRING
INSTRUCTIONS 
  MyValue:= ''
  MyHeader:= pKey+SepChar+STR(pINumber,5)
  IF MaxModeLen<>0 THEN
    MyHeader:= MyHeader+FORMAT([[iData.ActiveMode]],MaxModeLen)
  ENDIF
  FOR index:= 0 TO VAL([[iData.GetFields(pBlockName).Count]])-1 DO //loop all fields of the block
    aLocName:= [[iData.GetFields(pBlockName)[Index].LocalName]]
    IF pBlockName<>'' THEN //main block!
      FN:= pBlockName+'.'+aLocName
    ELSE
      FN:= aLocName
    ENDIF  
    MyType:= [[iData.GetField(FN).Definition.Type.Structure]]
    MyKind:= [[iData.GetField(FN).Definition.FieldKind]]
    IF MyKind = 'DataField' THEN //only process data fields
      IF MyType = 'BlockName' THEN 
        MyTypeName:= [[iData.GetField(FN).Definition.Type.HierarchicalName]]
        IF [[iData.GetField(FN).IsEmpty]]='False' THEN
          MyBlocks.GET(FN)
          IF FixedField=No then
            MyValue:= MyValue+SepChar+STR(MyBlocks.Instance)
          ELSE  
            MyValue:= MyValue+STR(MyBlocks.Instance,5)
          ENDIF
          Ins:= MyBlocks.Instance
          BTName:= MyBlocks.BlockTypeName
          LoopBlocks(pKey,FN,Ins,BTName,pINumber,pBlockTypeName,nest) //recursion
        ELSE
          IF FixedField=No then
            MyValue:= MyValue+SepChar   
          ELSE
            MyValue:= MyValue+FILL(' ',5)  //'empty' instance number 1..99999 
          ENDIF   
        ENDIF
      ELSEIF MyType = 'Array' THEN
        min_a:= VAL([[iData.GetField(FN).Definition.Type.IndexType.MinIndex]])
        max_a:= VAL([[iData.GetField(FN).Definition.Type.IndexType.MaxIndex]])
        s:= FN+'['+FORMAT(STR(min_a),LEN(str(max_a)),right,'0')+']'
        MyType:= [[iData.GetField(s).Definition.Type.Structure]]
        FOR aindex:= min_a TO max_a DO //loop all array elements
          aName:= FN+'['+FORMAT(str(aindex),LEN(STR(max_a)),RIGHT,'0')+']'
          IF MyType = 'BlockName' THEN //array field is a block
            MyTypeName:= [[iData.getfield(AName).Definition.Type.HierarchicalName]]
            IF [[iData.GetField(AName).IsEmpty]]='False' THEN
              MyBlocks.GET(AName)
              IF FixedField=No then
                MyValue:= MyValue+SepChar+STR(MyBlocks.Instance)
              ELSE  
                MyValue:= MyValue+STR(MyBlocks.Instance,5)
              ENDIF
              Ins:= MyBlocks.Instance
              BTName:= MyBlocks.BlockTypeName
              LoopBlocks(pKey,aName,Ins,BTName,pINumber,pBlockTypeName,nest+1) //recursion
            ELSE //block is empty   
              IF FixedField=No then
                MyValue:= MyValue+SepChar   
              ELSE
                MyValue:= MyValue+FILL(' ',5)  //'empty' instance number 1..99999 
              ENDIF   
            ENDIF
          ELSE //array field is base field
            ProcessFieldProperties(pKey,pBlockName,pINumber,AName,pBlockTypeName)
            MyValue:= MyValue+SepChar+ValueOfEndField(pBlockName,AName,pKey,pINumber)
          ENDIF
        ENDDO
      ELSE //end field
        ProcessFieldProperties(pKey,pBlockName,pINumber,FN,pBlockTypeName)
        MyValue:= MyValue+SepChar+ValueOfEndField(pBlockName,FN,pKey,pINumber)             
      ENDIF  
    ENDIF
  ENDDO
  IF pBlockName<>'' THEN
    MyBlocks.GET(pBlockName)
    oData.Value:= FORMAT(MyBlocks.BlockTypeName,MaxBlockTypeLen)+SepChar+
                  FORMAT(MyBlocks.BlockFieldName,MaxBlockNameLen)+SepChar+
                  MyHeader+SepChar
    IF FixedField=No THEN              
      oData.Value:= oData.Value+
                    pOBlockTypeName+Sepchar+
                    STR(pOINumber)
    ELSE
      oData.Value:= oData.Value+
                    FORMAT(pOBlockTypeName,MaxBlockTypeLen)+
                    STR(pOINumber,5)
    ENDIF                
                  
  ELSE //the main block
    oData.value:= FORMAT('$main',MaxBlockTypeLen)+SepChar+  //$main was: [[Data.Datamodel.Name]]
                  FORMAT('',MaxBlockNameLen)+SepChar+
                  MyHeader
  ENDIF  
  oData.value:= oData.value+MyValue
  oData.WRITE
ENDPROCEDURE{ loopBlocks }

PROCEDURE ProcessTheData
AUXFIELDS  
  res: INTEGER
  aKey: STRING
INSTRUCTIONS
  oData.OPEN(BaseDataName+'.data'+BaseDataExt)
  myblocks.SETREADKEY(PRIMARY)
  myBlocks.RESET
  res:= iData.OPEN(BlaiseDataFileName)
  IF res=0 THEN
    REPEAT
      iData.READNEXT
      IF RunRules=Yes THEN
        iData.CHECKRULES
      ENDIF
      IF [[iData.Keys.Contains('Primary')]]='True' THEN
        aKey:= iData.KEY
      ELSE
       aKey:= STR(iData.FORMNUMBER,8) 
      ENDIF
      IF iData.resultok THEN LoopBlocks(aKey,'',1,'',1,'',0) ENDIF
    UNTIL iData.LASTRECORD //{$IFDEF DEBUG}or data.recordnumber=10{$ENDIF} 
  ENDIF
ENDPROCEDURE

PROCEDURE CreateOutputFiles
AUXFIELDS
  aBlockTypeName: STRING
  tmpBTN: STRING
  aRecNr: INTEGER
  res: INTEGER
INSTRUCTIONS
  MyBlocks.SETREADKEY(SECONDARY)
  MyBlocks.RESET
  aBlockTypeName:= ''
  FOR aRecNr:= 1 TO MyBlocks.RECORDCOUNT DO
    MyBlocks.READNEXT
    tmpBTN:= MyBlocks.BlockTypeName
    IF tmpBTN<>aBlockTypeName THEN
      res:= oData_Block.OPEN(BaseDataName+'.'+tmpBTN+BaseDataExt)
      IF res=0 THEN oData_Block.RELEASE ENDIF
      aBlockTypeName:= tmpBTN
    ENDIF  
  ENDDO
ENDPROCEDURE

PROCEDURE ReadRequiredMeta
AUXFIELDS 
  i: INTEGER
  FName: STRING
  oldtypename: STRING
  PrevInstance: INTEGER
  Res: INTEGER
  FPT: STRING
  Card, FPT_Len: INTEGER
INSTRUCTIONS
  FName:= ExtractFilePath([[iData.Datamodel.FileName]])+[[iData.Datamodel.Name]]+'.names.xml'
  IF not FileExists(FName) THEN
    DISPLAY('Meta file '+FName+' not present. Run script AsciiRelGenerator_Meta first.',WAIT)
    HALT
  ELSE
    MyBlocksGenI.OPEN(FName)
    REPEAT
      MyBlocksGenI.READNEXT
      MyBlocks.WRITE
      MaxBlockTypeLen:= MAX(MaxBlockTypeLen,LEN(MyBlocks.BlockTypeName))
      MaxBlockNameLen:= MAX(MaxBlockNameLen,LEN(MyBlocks.BlockFieldName))
      MaxLocalNameLen:= MAX(MaxLocalNameLen,LEN(MyBlocks.LocalName))
      MaxOwnerTypeName:= MAX(MaxOwnerTypeName,LEN(MyBlocks.OwnerTypeName))
    UNTIL MyBlocksGenI.LASTRECORD
  ENDIF
{$IFDEF UseBlockMetaXML}  
  IF RunRules=Yes THEN
    FName:= ExtractFilePath([[iData.Datamodel.FileName]])+[[iData.Datamodel.Name]]+'.blockmeta.xml'
    IF not FileExists(FName) THEN
      DISPLAY('Block Meta file '+FName+' not present. Run script AsciiRelGenerator_Meta first.',WAIT)
      HALT
    ELSE
      MyBlocksMetaGenI.OPEN(FName)
      REPEAT
        MyBlocksMetaGenI.READNEXT
        MyBlockTypeMeta.WRITE
      UNTIL MyBlocksMetaGenI.LASTRECORD
    ENDIF
  ENDIF
{$ENDIF}  
  IF VAL([[iData.Datamodel.FieldProperties.Count]])>0 THEN
    FOR i:= 0 TO VAL([[iData.Datamodel.FieldProperties.Count]])-1 DO
      IF [[iData.Datamodel.FieldProperties[i].DataKind]]='Persistent' THEN
        MaxFieldPropertyLen:= MAX(MaxFieldPropertyLen,len([[iData.Datamodel.FieldProperties[i].Name]]))
        FPT:= [[iData.Datamodel.FieldProperties[i].Type.Structure]]
        CASE FPT OF
        'Enumeration': FPT_Len:= LEN([[iData.Datamodel.FieldProperties[i].Type.MaxValue]])
        'Set': Card:= VAL([[iData.Datamodel.FieldProperties[i].Type.Cardinality]]) 
               IF Card=0 THEN Card:= VAL([[iData.Datamodel.FieldProperties[i].Type.MemberType.Categories.Count]]) ENDIF
               FPT_Len:= Card*LEN([[iData.Datamodel.FieldProperties[i].Type.MemberType.MaxValue]])+(Card-1)
        'String': FPT_Len:= VAL([[iData.Datamodel.FieldProperties[i].Type.MaxLength]]) 
                  IF FPT_Len=0 THEN FPT_Len:= 2000 ENDIF
        ELSE FPT_Len:= VAL([[iData.Datamodel.FieldProperties[i].Type.MaxLength]])
        ENDCASE
        MaxFieldPropertyValueLen:= MAX(MaxFieldPropertyValueLen,FPT_Len)
      ENDIF  
    ENDDO
  ENDIF  
ENDPROCEDURE
  
PROCEDURE Initialize
AUXFIELDS 
  i: INTEGER
  tmp: STRING
INSTRUCTIONS
  SepChar:= '' //for output data. For now: fixed. No delimitor yet.
  DelimChar:= '"'
  FixedField:= Yes
  RepeatSpecialAnswerInSet:= 1
  IF [[iData.Datamodel.Modes.Count]]<>'0' THEN
    FOR i:= 0 to VAL([[iData.Datamodel.Modes.Count]])-1 DO
      MaxModeLen:= MAX(MaxModeLen,LEN([[iData.Datamodel.Modes[i].Name]]))
    ENDDO
  ENDIF  
  IF UPPERCASE(PARAMETER(1))='Y' THEN 
    RunRules:= Yes
  ENDIF
  IF PARAMETER(2)<>'' THEN 
    FixedField:= No 
    IF UPPERCASE(PARAMETER(2))='TAB' THEN 
      SepChar:= CHAR(9) 
    ELSE 
      SepChar:= PARAMETER(2) 
    ENDIF
  ENDIF
  IF PARAMETER(3)='Y' THEN
    DoWriteANSI:= Yes
  ENDIF  
  MaxBlockTypeLen:= LEN('$main') 
  AlsoExportOpen:= 1 //also export the OPEN type questions
  AlsoExportBlob:= 1 //also export the BLOBTYPE type questions
  FOR i:=  0 TO  VAL([[iData.Datamodel.SpecialAnswers.Count]])-1 DO
    tmp:= UPPERCASE([[iData.Datamodel.SpecialAnswers[i].Name]])
    IF NOT (tmp IN ['REFUSAL','DONTKNOW']) THEN //excluded because they can be redefined...
      UserDefSpecialAnswers:= Yes
    ENDIF
  ENDDO
  BlaiseDataFileName:= iData.PATHNAME+iData.FILENAME
  IF BlaiseDataFileName='' THEN
    BlaiseDataFileName:= ReplaceExtension([[meta.FileName]],'.bdix')
  ENDIF  
  BaseDataName:= oData.PATHNAME+oData.FILENAME
  BaseDataExt:= ExtractFileExtension(BaseDataName)
  BaseDataName:= SUBSTRING(BaseDataName,1,LEN(BaseDataName)-LEN(BaseDataExt))
  IF BaseDataName='' THEN 
    BaseDataName:= BlaiseDataFileName
  ENDIF
  IF BaseDataExt='' THEN BaseDataExt:= '.asc' ENDIF
  IF DoWriteAnsi=Yes THEN
    oData_Block.SETCHARACTERSET('ANSI') //check out. used to accept also ANSI as literal
  ENDIF  

ENDPROCEDURE 

PROCEDURE WriteOutput
AUXFIELDS
  tmp: STRING
  auxBlockTypeName: STRING
INSTRUCTIONS
//Each entry in the sorted list starts with the block type name (fixed length). This part is removed before writing 
//the actual output for each block type. $main, $open en $fps are 'faked' block types to enable to sort to work
//properly. For $main also the instance name (always 'empty') and the instance number (always 1) are removed.
  {$IFDEF DEBUG}
  oData.WRITE //all data is also written to this file for easy inspection
  {$ENDIF}
  auxBlockTypeName:= TRIM(SUBSTRING(oData.Value,1,MaxBlockTypeLen))
  IF auxBlockTypeName<>auxCurrentBlockTypeName THEN
    auxCurrentBlockTypeName:= auxBlockTypeName
    oData_Block.OPEN(BaseDataName+'.'+auxCurrentBlockTypeName+BaseDataExt)
    {$IFDEF TESTIMPORT}
    TestRun.Line:= '-k:meta="'+ ExtractFilePath([[iData.Datamodel.FileName]])+[[iData.Datamodel.Name]]+'.'+auxCurrentBlockTypeName+'.bmix"'+
          ' -i:"'+BaseDataName+'.'+auxCurrentBlockTypeName+BaseDataExt+'"'+
          ' -o:"'+BaseDataName+'.'+auxCurrentBlockTypeName+'I.bdbx'+'"'+
          ' -r:"'+auxCurrentBlockTypeName+'_message.txt"' 
    TestRun.Write
    {$ENDIF}
  ENDIF
  IF FixedField=No THEN
    oData_BLOCK.Value:= SUBSTRING(oData.Value,MaxBlockTypeLen+2,LEN(oData.Value)) //remove the block type name from the output
  ELSE
    oData_BLOCK.Value:= SUBSTRING(oData.Value,MaxBlockTypeLen+1,LEN(oData.Value)) //remove the block type name from the output
  ENDIF
  tmp:= SUBSTRING(oData_BLOCK.Value,1,MaxBlockNameLen)
  IF TRIM(tmp)='' THEN //main block. Strip the name of the Block and the Instance number
    IF FixedField=No THEN 
      oData_BLOCK.Value:= SUBSTRING(oData_BLOCK.Value,MaxBlockNameLen+2,LEN(oData_BLOCK.Value))
    ELSE
      oData_BLOCK.Value:= SUBSTRING(oData_BLOCK.Value,MaxBlockNameLen+1,LEN(oData_BLOCK.Value))
    ENDIF  
  ENDIF
  oData_BLOCK.WRITE
ENDPROCEDURE   

MANIPULATE
  Initialize
  ReadRequiredMeta
  CreateOutputFiles
  ProcessTheData
  
SORT
  Value

MANIPULATE
  WriteOutput
